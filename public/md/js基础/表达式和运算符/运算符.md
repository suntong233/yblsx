## 运算符
    运算符用于算术表达式等表达式。

### 运算符表，此表是按照运算符的优先级顺序排序

|运算符|操作|
|-|-|
|++|前/后增量|
|- -|前/后减量|
|-|求反|
|+|转换为数字|
|~|按位求反|
|！|逻辑非|
|delete|删除属性|
|typeof|检测类型|
|void|返回undefined|
|* / %|乘除求模|
|+ -|算术加减|
|+|字符串连接|
|<<|左移位|
|>>|有符号右移|
|>>>|无符号右移|
|< <= > >=|比较数字顺序|
|< <= > >=|比较字母顺序|
|instanceof|测试对象类|
|in|测试属性是否存在|
|==|相等|
|!=|不等|
|===|恒等|
|!==|不恒等|
|&|按位与|
|^|按位异或|
|\||按位或|
|&&|逻辑与|
|\|\||逻辑或|
|？：|条件运算符|
|=|变量或对象属性赋值|
|*= /= += -= &=|运算且赋值|
|^= \|= <<= >>= >>>=||

### 操作数的个数

运算符可以根据其操作数的个数进行分类。 

大多数的运算符比如 + - * / 是一个二元运算符，将两个表达式合并成一个稍微复杂的。  -x  中的-相当于一元运算符  是得负值  而 ？： 三元运算符

### 算术表达式
* 就是简单的 + - * / % 

### “+”运算符
    除了可以做算术，还可以用来做字符串的拼接，以及字符串转数字+x

```js
    1 + 2    // 3 加法
    "1" + "2"  //"12" 字符串拼接
    "1" + 2  //"12" 数字转换为字符串后进行字符串连接
    1 + {}  //"1[object Object]"  对象转换成字符串后连接
    true + true // 2  布尔值转化为1后加法
    2 + null   //2   null 转化为0
    2 + undefined  // NaN undefined转换为NaN后做加法
```

### 一元算术运算符

  *  \+ \-  ++ --  分别是转换成数字和数字的负符号 递增递减

  ++  --   如果是++x  则会返回x+1的值  x++则是返回x 然后再加一

### 位运算

* 按位的 与& 或\ 异或^

    & 两边都是1 返回1

    \ 有一个是1 返回1

    ^ 两边都是1 或两边都是0  返回1

### == 与 ===

* 都用来检测两边的是否相等，并返回true或false
* === 用来检测是否严格相等。 == 允许自动类型转换

### 比较运算符 
* <小于   >大于  <=小于等于   >=大于等于

### in运算符

* 左操作数是一个字符串或可以转换成字符串，而右操作符是一个对象。要求右侧的对象拥有一个名为左操作符数值的属性名，就会返回true

```js
    var obj = { x:1 , y:2};
    "x" in obj    //true
    "z" in obj    //false
    "toString" in obj   //true  继承得来的属性

    var arr = [7,8,9]
    "0" in data   //true
    1 in data    //true 1转化为"1"
    3 in data   //false 没有索引为3得元素
```
@@@@@@@@@@@@@@@@@关于继承得属性
```js
    // let obj1 ={a:1};
    // let obj2 = {b:2,obj1};  
```

### instanceof运算符
* instanceof 运算符的左操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧的实例，则返回true；否则返回false。对象的类是通过初始化它们的构造函数来定义的。
```js
    var d = new Date();
    d instanceof Date;   //true  d是由Date()创建的
    d instanceof Object  //true  所有对象都是Object的实例
    d instanceof Number  //false  d不少一个Number对象
    var a = [1,2,3];
    a instanceof Array    //true a 是数组
    a instanceof Object   //true
    a instanceof RegExp   //false  a不是正则表达式
```

* 所有的对象都是Object的实例。当通过instanceof判断一个对象是否是一个类的实例的时候，这个判断也包含对“父亲”的检测。
* 为了理解instanceof运算符是如何工作的，要理解“原型链”(prototypechain)。例如 a instanceof b。JS会先计算b.proptotype，然后在原型链中查找a，如果找到，那么a是b或者b的父类的一个实例。

### 逻辑表达式
* && || !
####  &&的三层理解
* 第一层 &&对两边的布尔值执行布尔与操作。只有在第一个操作数和第二个都是true才返回true。
* 第二层，&&的操作数不一定是布尔值，有些值可以当作“真值”和假值。而&&可以对真值和假值进行布尔与操作。如果两个都是真值，那么返回一个真值，否则，至少一个操作符是假值的话就返回假值。
* 第三层，运算符首先计算左操作数的值，即先计算&&左侧的表达式。如果计算结果是假值的话，那么整个表达式的结果一定也是假值，因此会直接返回左侧的值而不去操作右侧。而如果左侧是真值，同理，接下来会依赖右侧的值，所以会返回右侧。
```js
    var o = {x:1};
    var p = null;
    o && o.x    //返回1 因为 o 是真值，所以返回右侧
    p && p.x    //null  p是假值，所以直接返回p 不计算p.x
```
这样的现象叫做短路。以下是一个短路的用法;
```js
    //返回一个数组里值为3的索引
    let arr = [1,8,6,3,1,3];   //定义一个数组
    for(let i in arr){          //遍历数组
        (arr[i]==3) && console.log(i);  // 3 5
    }
    /* 与语句里，只要左操作数是假的，即arr[i]是不等于3，那么直接得到一个直接量，而不会再看右侧，相当于无效的行为。而如果左操作数是真，那么会直接执行console.log(i);    */
```

#### 逻辑||
* 对两个操作数做布尔或的运算，只要有一个是真值，就返回真值。
* 它会首先计算第一个操作数的值，如果为真就返回，否则再计算第二个操作数的值。
```js
    var x = max_width || 500   //首先发现没有max_width 那么直接赋值500
    function foo(o,p){
        p=p || {};//如果没有给p传入对象，则会使用一个空对象
    }
```
#### 逻辑非！
    求反，优先级大于&&跟||，返回布尔值。

### 赋值表达式

* +=  -=  *=  /=  %=  <<=   >>=  >>>=  &=  |=  ^=

### eval
    Js可以解释运行由JavaScript源代码组成的字符串。

    eval("3+2");   //=>5


### 三元运算符

?:

x>0 ? x : -x  //求x的绝对值

### delete运算符

delete是一元操作符，用来删除对象属性或数组元素。

delete删除数组元素，会设置一个undefined值，而删除一个属性时，这个属性将不再存在。

### void运算符
返回undefined。